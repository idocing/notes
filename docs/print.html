<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/rust-syntax-bg-highlight.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> README</a></li><li class="chapter-item expanded "><a href="os/firewall.html"><strong aria-hidden="true">2.</strong> os</a></li><li class="chapter-item expanded "><a href="rust/abi.html"><strong aria-hidden="true">3.</strong> rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/abi.html"><strong aria-hidden="true">3.1.</strong> abi</a></li><li class="chapter-item expanded "><a href="rust/ffi.html"><strong aria-hidden="true">3.2.</strong> ffi</a></li><li class="chapter-item expanded "><a href="rust/mem.html"><strong aria-hidden="true">3.3.</strong> mem</a></li><li class="chapter-item expanded "><a href="rust/offline.html"><strong aria-hidden="true">3.4.</strong> offline</a></li><li class="chapter-item expanded "><a href="rust/rc&cell.html"><strong aria-hidden="true">3.5.</strong> rc&cell</a></li></ol></li><li class="chapter-item expanded "><a href="windows/service.html"><strong aria-hidden="true">4.</strong> windows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="windows/service.html"><strong aria-hidden="true">4.1.</strong> service</a></li></ol></li><li class="chapter-item expanded "><a href="word/pg.html"><strong aria-hidden="true">5.</strong> word</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="word/pg.html"><strong aria-hidden="true">5.1.</strong> pg</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="mdbook"><a class="header" href="#mdbook">mdbook</a></h1>
<h2 id="mdbook-install"><a class="header" href="#mdbook-install">mdbook install</a></h2>
<pre><code>cargo install mdbook
</code></pre>
<h2 id="mdbook-init"><a class="header" href="#mdbook-init">mdbook init</a></h2>
<pre><code>mdbook init
</code></pre>
<h2 id="mdbook-build"><a class="header" href="#mdbook-build">mdbook build</a></h2>
<pre><code>mdbook build
</code></pre>
<h2 id="mdbook-serve"><a class="header" href="#mdbook-serve">mdbook serve</a></h2>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>设置防火墙并允许某些端口通常涉及以下步骤，具体操作可能因操作系统和防火墙软件的不同而有所差异。以下是如何在不同操作系统上进行这些操作的基本指南：</p>
<h3 id="windows-防火墙"><a class="header" href="#windows-防火墙">Windows 防火墙</a></h3>
<ol>
<li>
<p><strong>打开防火墙设置:</strong></p>
<ul>
<li>通过控制面板，找到并打开 <strong>"Windows Defender 防火墙"</strong>。</li>
<li>或者，在开始菜单中搜索 "防火墙" 并选择 <strong>"Windows Defender 防火墙"</strong>。</li>
</ul>
</li>
<li>
<p><strong>允许特定端口:</strong></p>
<ul>
<li>在左侧菜单中，点击 <strong>"高级设置"</strong>，将打开 "Windows Defender 防火墙与高级安全" 窗口。</li>
<li>在左侧点击 <strong>"入站规则"</strong> 或 <strong>"出站规则"</strong>，然后在右侧点击 <strong>"新建规则"</strong>。</li>
<li>选择 <strong>"端口"</strong> 作为规则类型，点击 <strong>"下一步"</strong>。</li>
<li>选择 <strong>"TCP"</strong> 或 <strong>"UDP"</strong> 协议，并指定要允许的端口号或端口范围（如 <code>80, 443</code> 或 <code>8000-9000</code>）。</li>
<li>选择 <strong>"允许连接"</strong>，然后点击 <strong>"下一步"</strong>。</li>
<li>选择应用此规则的网络类型（域、专用或公用），然后点击 <strong>"下一步"</strong>。</li>
<li>为规则命名并点击 <strong>"完成"</strong>。</li>
</ul>
</li>
<li>
<p><strong>验证设置:</strong></p>
<ul>
<li>你可以通过 <code>netsh advfirewall firewall show rule name=all</code> 在命令提示符下查看当前的防火墙规则。</li>
</ul>
</li>
</ol>
<h3 id="linux-以-ufw-为例"><a class="header" href="#linux-以-ufw-为例">Linux (以 <code>ufw</code> 为例)</a></h3>
<ol>
<li>
<p><strong>安装并启用 <code>ufw</code>:</strong></p>
<pre><code class="language-bash">sudo apt-get install ufw
sudo ufw enable
</code></pre>
</li>
<li>
<p><strong>允许特定端口:</strong></p>
<ul>
<li>允许单个端口：
<pre><code class="language-bash">sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
</code></pre>
</li>
<li>允许端口范围：
<pre><code class="language-bash">sudo ufw allow 8000:9000/tcp
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>查看规则:</strong></p>
<ul>
<li>使用以下命令查看当前的规则：
<pre><code class="language-bash">sudo ufw status
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>禁用特定端口:</strong></p>
<ul>
<li>使用以下命令禁用某个端口：
<pre><code class="language-bash">sudo ufw deny 80/tcp
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="macos-防火墙"><a class="header" href="#macos-防火墙">macOS 防火墙</a></h3>
<ol>
<li>
<p><strong>打开防火墙设置:</strong></p>
<ul>
<li>进入 <strong>"系统偏好设置"</strong>，选择 <strong>"安全性与隐私"</strong>，然后选择 <strong>"防火墙"</strong> 标签。</li>
<li>点击左下角的锁图标以进行更改（如果防火墙未启用，先点击 <strong>"启用防火墙"</strong>）。</li>
</ul>
</li>
<li>
<p><strong>配置防火墙选项:</strong></p>
<ul>
<li>点击 <strong>"防火墙选项"</strong>，你可以添加应用程序或服务，并为其选择允许或阻止连接。</li>
</ul>
</li>
<li>
<p><strong>通过命令行允许端口:</strong></p>
<ul>
<li>macOS 原生防火墙不提供端口级别的设置，如果需要更细粒度的控制，你可能需要使用第三方工具，如 <code>pf</code> (Packet Filter)：
<pre><code class="language-bash">sudo vim /etc/pf.conf
</code></pre>
</li>
<li>在文件中添加允许规则，然后重新加载配置：
<pre><code class="language-bash">sudo pfctl -f /etc/pf.conf
sudo pfctl -e
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>具体的防火墙设置步骤会因操作系统和需求不同而有差异。对于大多数用户而言，Windows 和 <code>ufw</code> 是简单易用的防火墙配置工具。如果你有更复杂的需求，可能需要使用高级防火墙工具如 <code>iptables</code>（Linux）或 <code>pf</code>（macOS）。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在Rust中使用ABI和FFI与C/C++代码交互时，你需要确保Rust的数据类型能够正确地映射到C/C++的数据类型。以下是一个详细的对照表，列出了Rust中的数据类型与C/C++中的对应类型：</p>
<h3 id="整数类型"><a class="header" href="#整数类型">整数类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td><code>signed char</code></td></tr>
<tr><td><code>u8</code></td><td><code>unsigned char</code></td></tr>
<tr><td><code>i16</code></td><td><code>short</code></td></tr>
<tr><td><code>u16</code></td><td><code>unsigned short</code></td></tr>
<tr><td><code>i32</code></td><td><code>int</code></td></tr>
<tr><td><code>u32</code></td><td><code>unsigned int</code></td></tr>
<tr><td><code>i64</code></td><td><code>long long</code></td></tr>
<tr><td><code>u64</code></td><td><code>unsigned long long</code></td></tr>
<tr><td><code>isize</code></td><td><code>ptrdiff_t</code> / <code>ssize_t</code></td></tr>
<tr><td><code>usize</code></td><td><code>size_t</code></td></tr>
</tbody></table>
</div>
<h3 id="浮点数类型"><a class="header" href="#浮点数类型">浮点数类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>f32</code></td><td><code>float</code></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td></tr>
</tbody></table>
</div>
<h3 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>int</code></td></tr>
</tbody></table>
</div>
<h3 id="字符类型"><a class="header" href="#字符类型">字符类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>wchar_t</code></td></tr>
</tbody></table>
</div>
<h3 id="指针类型"><a class="header" href="#指针类型">指针类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>*const T</code></td><td><code>const T *</code></td></tr>
<tr><td><code>*mut T</code></td><td><code>T *</code></td></tr>
</tbody></table>
</div>
<h3 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>&amp;'a str</code></td><td><code>const char *</code></td></tr>
<tr><td><code>String</code></td><td><code>char *</code></td></tr>
</tbody></table>
</div>
<h3 id="数组和向量"><a class="header" href="#数组和向量">数组和向量</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>&amp;'a [T]</code></td><td><code>const T *</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>T *</code></td></tr>
</tbody></table>
</div>
<h3 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>extern "C" fn(...)</code></td><td><code>void (*)()</code></td></tr>
<tr><td><code>extern "C" fn(i32, i32) -&gt; i32</code></td><td><code>int (*)(int, int)</code></td></tr>
</tbody></table>
</div>
<h3 id="结构体和枚举"><a class="header" href="#结构体和枚举">结构体和枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>struct</code></td><td><code>struct</code></td></tr>
<tr><td><code>enum</code></td><td><code>enum</code></td></tr>
</tbody></table>
</div>
<h3 id="特殊类型"><a class="header" href="#特殊类型">特殊类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>c_void</code></td><td><code>void</code></td></tr>
</tbody></table>
</div>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<ol>
<li>
<p><strong>布尔类型</strong> (<code>bool</code>)：在 C/C++ 中通常使用 <code>int</code> 来表示布尔值，而在 Rust 中则使用专门的 <code>bool</code> 类型。在 FFI 的上下文中，<code>bool</code> 通常会被转换为 <code>i32</code> 或 <code>u32</code>。</p>
</li>
<li>
<p><strong>字符类型</strong> (<code>char</code>)：Rust 的 <code>char</code> 类型是一个 Unicode 标量值，而 C/C++ 语言中的 <code>char</code> 类型是一个单字节字符。在 FFI 中，通常使用 <code>u16</code> 或 <code>u32</code> 来表示 Unicode 字符，这取决于目标平台的宽字符类型。</p>
</li>
<li>
<p><strong>字符串类型</strong> (<code>&amp;str</code> 和 <code>String</code>)：在 Rust 中，<code>&amp;str</code> 是一个不可变的引用到有效的 UTF-8 编码的字符串切片，而 <code>String</code> 是一个可变的字符串缓冲区。在 C/C++ 中，字符串通常由一个空终止的字符数组表示。在 FFI 的上下文中，你通常需要使用 <code>*const i8</code> 或 <code>*const u8</code> 来表示 C 字符串。</p>
</li>
<li>
<p><strong>动态数组</strong> (<code>Vec&lt;T&gt;</code>)：Rust 中的 <code>Vec&lt;T&gt;</code> 类型类似于 C/C++ 中的动态数组。在 FFI 中，你通常需要使用裸指针 <code>*mut T</code> 来表示动态分配的数组，并且可能需要额外的长度参数来指示数组的大小。</p>
</li>
<li>
<p><strong>函数指针</strong>：Rust 中的函数指针类型（例如 <code>extern "C" fn(i32, i32) -&gt; i32</code>）可以直接映射到 C/C++ 中的函数指针类型。</p>
</li>
<li>
<p><strong>结构体和枚举</strong>：Rust 的结构体和枚举可以映射到 C/C++ 中的结构体和枚举，但是需要注意内存布局和对齐规则。在 Rust 中使用 <code>repr(C)</code> 属性可以确保结构体具有与 C/C++ 语言相同的布局。</p>
</li>
<li>
<p><strong><code>std::os::raw::c_*</code> 类型</strong>：在 Rust 的标准库中，<code>std::os::raw</code> 模块提供了与 C/C++ 类型直接对应的原始类型，例如 <code>c_char</code>、<code>c_int</code> 等，这些类型在编写 FFI 接口时非常有用。</p>
</li>
</ol>
<p>请注意，上述对照表并不是详尽无遗的，但它涵盖了大多数常见的场景。在实际使用中，你还需要考虑特定平台和库的细节，以及 Rust 和 C/C++ 之间的任何潜在差异。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在Rust中使用ABI和FFI与C/C++代码交互时，你需要确保Rust的数据类型能够正确地映射到C/C++的数据类型。以下是一个详细的对照表，列出了Rust中的数据类型与C/C++中的对应类型：</p>
<h3 id="整数类型-1"><a class="header" href="#整数类型-1">整数类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td><code>signed char</code></td></tr>
<tr><td><code>u8</code></td><td><code>unsigned char</code></td></tr>
<tr><td><code>i16</code></td><td><code>short</code></td></tr>
<tr><td><code>u16</code></td><td><code>unsigned short</code></td></tr>
<tr><td><code>i32</code></td><td><code>int</code></td></tr>
<tr><td><code>u32</code></td><td><code>unsigned int</code></td></tr>
<tr><td><code>i64</code></td><td><code>long long</code></td></tr>
<tr><td><code>u64</code></td><td><code>unsigned long long</code></td></tr>
<tr><td><code>isize</code></td><td><code>ptrdiff_t</code> / <code>ssize_t</code></td></tr>
<tr><td><code>usize</code></td><td><code>size_t</code></td></tr>
</tbody></table>
</div>
<h3 id="浮点数类型-1"><a class="header" href="#浮点数类型-1">浮点数类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>f32</code></td><td><code>float</code></td></tr>
<tr><td><code>f64</code></td><td><code>double</code></td></tr>
</tbody></table>
</div>
<h3 id="布尔类型-1"><a class="header" href="#布尔类型-1">布尔类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>int</code></td></tr>
</tbody></table>
</div>
<h3 id="字符类型-1"><a class="header" href="#字符类型-1">字符类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>wchar_t</code></td></tr>
</tbody></table>
</div>
<h3 id="指针类型-1"><a class="header" href="#指针类型-1">指针类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>*const T</code></td><td><code>const T *</code></td></tr>
<tr><td><code>*mut T</code></td><td><code>T *</code></td></tr>
</tbody></table>
</div>
<h3 id="字符串类型-1"><a class="header" href="#字符串类型-1">字符串类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>&amp;'a str</code></td><td><code>const char *</code></td></tr>
<tr><td><code>String</code></td><td><code>char *</code></td></tr>
</tbody></table>
</div>
<h3 id="数组和向量-1"><a class="header" href="#数组和向量-1">数组和向量</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>&amp;'a [T]</code></td><td><code>const T *</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>T *</code></td></tr>
</tbody></table>
</div>
<h3 id="函数指针-1"><a class="header" href="#函数指针-1">函数指针</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>extern "C" fn(...)</code></td><td><code>void (*)()</code></td></tr>
<tr><td><code>extern "C" fn(i32, i32) -&gt; i32</code></td><td><code>int (*)(int, int)</code></td></tr>
</tbody></table>
</div>
<h3 id="结构体和枚举-1"><a class="header" href="#结构体和枚举-1">结构体和枚举</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>struct</code></td><td><code>struct</code></td></tr>
<tr><td><code>enum</code></td><td><code>enum</code></td></tr>
</tbody></table>
</div>
<h3 id="特殊类型-1"><a class="header" href="#特殊类型-1">特殊类型</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Rust 类型</th><th>C/C++ 类型</th></tr></thead><tbody>
<tr><td><code>c_void</code></td><td><code>void</code></td></tr>
</tbody></table>
</div>
<h3 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h3>
<ol>
<li>
<p><strong>布尔类型</strong> (<code>bool</code>)：在 C/C++ 中通常使用 <code>int</code> 来表示布尔值，而在 Rust 中则使用专门的 <code>bool</code> 类型。在 FFI 的上下文中，<code>bool</code> 通常会被转换为 <code>i32</code> 或 <code>u32</code>。</p>
</li>
<li>
<p><strong>字符类型</strong> (<code>char</code>)：Rust 的 <code>char</code> 类型是一个 Unicode 标量值，而 C/C++ 语言中的 <code>char</code> 类型是一个单字节字符。在 FFI 中，通常使用 <code>u16</code> 或 <code>u32</code> 来表示 Unicode 字符，这取决于目标平台的宽字符类型。</p>
</li>
<li>
<p><strong>字符串类型</strong> (<code>&amp;str</code> 和 <code>String</code>)：在 Rust 中，<code>&amp;str</code> 是一个不可变的引用到有效的 UTF-8 编码的字符串切片，而 <code>String</code> 是一个可变的字符串缓冲区。在 C/C++ 中，字符串通常由一个空终止的字符数组表示。在 FFI 的上下文中，你通常需要使用 <code>*const i8</code> 或 <code>*const u8</code> 来表示 C 字符串。</p>
</li>
<li>
<p><strong>动态数组</strong> (<code>Vec&lt;T&gt;</code>)：Rust 中的 <code>Vec&lt;T&gt;</code> 类型类似于 C/C++ 中的动态数组。在 FFI 中，你通常需要使用裸指针 <code>*mut T</code> 来表示动态分配的数组，并且可能需要额外的长度参数来指示数组的大小。</p>
</li>
<li>
<p><strong>函数指针</strong>：Rust 中的函数指针类型（例如 <code>extern "C" fn(i32, i32) -&gt; i32</code>）可以直接映射到 C/C++ 中的函数指针类型。</p>
</li>
<li>
<p><strong>结构体和枚举</strong>：Rust 的结构体和枚举可以映射到 C/C++ 中的结构体和枚举，但是需要注意内存布局和对齐规则。在 Rust 中使用 <code>repr(C)</code> 属性可以确保结构体具有与 C/C++ 语言相同的布局。</p>
</li>
<li>
<p><strong><code>std::os::raw::c_*</code> 类型</strong>：在 Rust 的标准库中，<code>std::os::raw</code> 模块提供了与 C/C++ 类型直接对应的原始类型，例如 <code>c_char</code>、<code>c_int</code> 等，这些类型在编写 FFI 接口时非常有用。</p>
</li>
</ol>
<p>请注意，上述对照表并不是详尽无遗的，但它涵盖了大多数常见的场景。在实际使用中，你还需要考虑特定平台和库的细节，以及 Rust 和 C/C++ 之间的任何潜在差异。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-function-interface"><a class="header" href="#foreign-function-interface">Foreign Function Interface</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This guide will use the <a href="https://github.com/google/snappy">snappy</a>
compression/decompression library as an introduction to writing bindings for
foreign code. Rust is currently unable to call directly into a C++ library, but
snappy includes a C interface (documented in
<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
<h2 id="a-note-about-libc"><a class="header" href="#a-note-about-libc">A note about libc</a></h2>
<p>Many of these examples use <a href="https://crates.io/crates/libc">the <code>libc</code> crate</a>, which provides various
type definitions for C types, among other things. If you’re trying these
examples yourself, you’ll need to add <code>libc</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
libc = "0.2.0"
</code></pre>
<h2 id="calling-foreign-functions"><a class="header" href="#calling-foreign-functions">Calling foreign functions</a></h2>
<p>The following is a minimal example of calling a foreign function which will
compile if snappy is installed:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::size_t;

#[link(name = "snappy")]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!("max compressed length of a 100 byte buffer: {}", x);
}</code></pre>
<p>The <code>extern</code> block is a list of function signatures in a foreign library, in
this case with the platform's C ABI. The <code>#[link(...)]</code> attribute is used to
instruct the linker to link against the snappy library so the symbols are
resolved.</p>
<p>Foreign functions are assumed to be unsafe so calls to them need to be wrapped
with <code>unsafe {}</code> as a promise to the compiler that everything contained within
truly is safe. C libraries often expose interfaces that aren't thread-safe, and
almost any function that takes a pointer argument isn't valid for all possible
inputs since the pointer could be dangling, and raw pointers fall outside of
Rust's safe memory model.</p>
<p>When declaring the argument types to a foreign function, the Rust compiler
cannot check if the declaration is correct, so specifying it correctly is part
of keeping the binding correct at runtime.</p>
<p>The <code>extern</code> block can be extended to cover the entire snappy API:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::{c_int, size_t};

#[link(name = "snappy")]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
<span class="boring">fn main() {}</span></code></pre>
<h2 id="creating-a-safe-interface"><a class="header" href="#creating-a-safe-interface">Creating a safe interface</a></h2>
<p>The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts
like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe
internal details.</p>
<p>Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust
vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The
length is the number of elements currently contained, and the capacity is the total size in elements of
the allocated memory. The length is less than or equal to the capacity.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}</code></pre>
<p>The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the
guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function
signature.</p>
<p>The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be
allocated to hold the output too.</p>
<p>The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum
required capacity to hold the compressed output. The vector can then be passed to the
<code>snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve
the true length after compression for setting the length.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
</span><span class="boring">                          d: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
</span><span class="boring">fn main() {}
</span>pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}</code></pre>
<p>Decompression is similar, because snappy stores the uncompressed size as part of the compression
format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}</code></pre>
<p>Then, we can add some tests to show how to use them.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_compress(input: *const u8,
</span><span class="boring">                          input_length: size_t,
</span><span class="boring">                          compressed: *mut u8,
</span><span class="boring">                          compressed_length: *mut size_t)
</span><span class="boring">                          -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t)
</span><span class="boring">                            -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t)
</span><span class="boring">                                     -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,
</span><span class="boring">                                            compressed_length: size_t)
</span><span class="boring">                                            -&gt; c_int { 0 }
</span><span class="boring">fn main() { }
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn valid() {
        let d = vec![0xde, 0xad, 0xd0, 0x0d];
        let c: &amp;[u8] = &amp;compress(&amp;d);
        assert!(validate_compressed_buffer(c));
        assert!(uncompress(c) == Some(d));
    }

    #[test]
    fn invalid() {
        let d = vec![0, 0, 0, 0];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
    }

    #[test]
    fn empty() {
        let d = vec![];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
        let c = compress(&amp;d);
        assert!(validate_compressed_buffer(&amp;c));
        assert!(uncompress(&amp;c) == Some(d));
    }
}</code></pre>
<h2 id="destructors"><a class="header" href="#destructors">Destructors</a></h2>
<p>Foreign libraries often hand off ownership of resources to the calling code.
When this occurs, we must use Rust's destructors to provide safety and guarantee
the release of these resources (especially in the case of panic).</p>
<p>For more about destructors, see the <a href="rust/../std/ops/trait.Drop.html">Drop trait</a>.</p>
<h2 id="calling-rust-code-from-c"><a class="header" href="#calling-rust-code-from-c">Calling Rust code from C</a></h2>
<p>You may wish to compile Rust code in a way so that it can be called from C.
This is fairly easy, but requires a few things.</p>
<h3 id="rust-side"><a class="header" href="#rust-side">Rust side</a></h3>
<p>First, we assume you have a lib crate named as <code>rust_from_c</code>.
<code>lib.rs</code> should have Rust code as following:</p>
<pre><pre class="playground"><code class="language-rust">#[no_mangle]
pub extern "C" fn hello_from_rust() {
    println!("Hello from Rust!");
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <code>extern "C"</code> makes this function adhere to the C calling convention, as discussed below in "<a href="rust/ffi.html#foreign-calling-conventions">Foreign Calling Conventions</a>".
The <code>no_mangle</code> attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.</p>
<p>Then, to compile Rust code as a shared library that can be called from C, add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]
</code></pre>
<p>(NOTE: We could also use the <code>staticlib</code> crate type but it needs to tweak some linking flags.)</p>
<p>Run <code>cargo build</code> and you're ready to go on the Rust side.</p>
<h3 id="c-side"><a class="header" href="#c-side">C side</a></h3>
<p>We'll create a C file to call the <code>hello_from_rust</code> function and compile it by <code>gcc</code>.</p>
<p>C file should look like:</p>
<pre><code class="language-c">extern void hello_from_rust();

int main(void) {
    hello_from_rust();
    return 0;
}
</code></pre>
<p>We name the file as <code>call_rust.c</code> and place it on the crate root.
Run the following to compile:</p>
<pre><code class="language-sh">gcc call_rust.c -o call_rust -lrust_from_c -L./target/debug
</code></pre>
<p><code>-l</code> and <code>-L</code> tell gcc to find our Rust library.</p>
<p>Finally, we can call Rust code from C with <code>LD_LIBRARY_PATH</code> specified:</p>
<pre><code class="language-sh">$ LD_LIBRARY_PATH=./target/debug ./call_rust
Hello from Rust!
</code></pre>
<p>That's it!
For more realistic example, check the <a href="https://github.com/eqrion/cbindgen"><code>cbindgen</code></a>.</p>
<h2 id="callbacks-from-c-code-to-rust-functions"><a class="header" href="#callbacks-from-c-code-to-rust-functions">Callbacks from C code to Rust functions</a></h2>
<p>Some external libraries require the usage of callbacks to report back their
current state or intermediate data to the caller.
It is possible to pass functions defined in Rust to an external library.
The requirement for this is that the callback function is marked as <code>extern</code>
with the correct calling convention to make it callable from C code.</p>
<p>The callback function can then be sent through a registration call
to the C library and afterwards be invoked from there.</p>
<p>A basic example is:</p>
<p>Rust code:</p>
<pre><pre class="playground"><code class="language-rust no_run">extern fn callback(a: i32) {
    println!("I'm called from C with value {0}", a);
}

#[link(name = "extlib")]
extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // Triggers the callback.
    }
}</code></pre></pre>
<p>C code:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // Will call callback(7) in Rust.
}
</code></pre>
<p>In this example Rust's <code>main()</code> will call <code>trigger_callback()</code> in C,
which would, in turn, call back to <code>callback()</code> in Rust.</p>
<h2 id="targeting-callbacks-to-rust-objects"><a class="header" href="#targeting-callbacks-to-rust-objects">Targeting callbacks to Rust objects</a></h2>
<p>The former example showed how a global function can be called from C code.
However it is often desired that the callback is targeted to a special
Rust object. This could be the object that represents the wrapper for the
respective C object.</p>
<p>This can be achieved by passing a raw pointer to the object down to the
C library. The C library can then include the pointer to the Rust object in
the notification. This will allow the callback to unsafely access the
referenced Rust object.</p>
<p>Rust code:</p>
<pre><pre class="playground"><code class="language-rust no_run">struct RustObject {
    a: i32,
    // Other members...
}

extern "C" fn callback(target: *mut RustObject, a: i32) {
    println!("I'm called from C with value {0}", a);
    unsafe {
        // Update the value in RustObject with the value received from the callback:
        (*target).a = a;
    }
}

#[link(name = "extlib")]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // Create the object that will be referenced in the callback:
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}</code></pre></pre>
<p>C code:</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // Will call callback(&amp;rustObject, 7) in Rust.
}
</code></pre>
<h2 id="asynchronous-callbacks"><a class="header" href="#asynchronous-callbacks">Asynchronous callbacks</a></h2>
<p>In the previously given examples the callbacks are invoked as a direct reaction
to a function call to the external C library.
The control over the current thread is switched from Rust to C to Rust for the
execution of the callback, but in the end the callback is executed on the
same thread that called the function which triggered the callback.</p>
<p>Things get more complicated when the external library spawns its own threads
and invokes callbacks from there.
In these cases access to Rust data structures inside the callbacks is
especially unsafe and proper synchronization mechanisms must be used.
Besides classical synchronization mechanisms like mutexes, one possibility in
Rust is to use channels (in <code>std::sync::mpsc</code>) to forward data from the C
thread that invoked the callback into a Rust thread.</p>
<p>If an asynchronous callback targets a special object in the Rust address space
it is also absolutely necessary that no more callbacks are performed by the
C library after the respective Rust object gets destroyed.
This can be achieved by unregistering the callback in the object's
destructor and designing the library in a way that guarantees that no
callback will be performed after deregistration.</p>
<h2 id="linking"><a class="header" href="#linking">Linking</a></h2>
<p>The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for
instructing rustc how it will link to native libraries. There are two accepted
forms of the link attribute today:</p>
<ul>
<li><code>#[link(name = "foo")]</code></li>
<li><code>#[link(name = "foo", kind = "bar")]</code></li>
</ul>
<p>In both of these cases, <code>foo</code> is the name of the native library that we're
linking to, and in the second case <code>bar</code> is the type of native library that the
compiler is linking to. There are currently three known types of native
libraries:</p>
<ul>
<li>Dynamic - <code>#[link(name = "readline")]</code></li>
<li>Static - <code>#[link(name = "my_build_dependency", kind = "static")]</code></li>
<li>Frameworks - <code>#[link(name = "CoreFoundation", kind = "framework")]</code></li>
</ul>
<p>Note that frameworks are only available on macOS targets.</p>
<p>The different <code>kind</code> values are meant to differentiate how the native library
participates in linkage. From a linkage perspective, the Rust compiler creates
two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).
Native dynamic library and framework dependencies are propagated to the final
artifact boundary, while static library dependencies are not propagated at
all, because the static libraries are integrated directly into the subsequent
artifact.</p>
<p>A few examples of how this model can be used are:</p>
<ul>
<li>
<p>A native build dependency. Sometimes some C/C++ glue is needed when writing
some Rust code, but distribution of the C/C++ code in a library format is
a burden. In this case, the code will be archived into <code>libfoo.a</code> and then the
Rust crate would declare a dependency via <code>#[link(name = "foo", kind = "static")]</code>.</p>
<p>Regardless of the flavor of output for the crate, the native static library
will be included in the output, meaning that distribution of the native static
library is not necessary.</p>
</li>
<li>
<p>A normal dynamic dependency. Common system libraries (like <code>readline</code>) are
available on a large number of systems, and often a static copy of these
libraries cannot be found. When this dependency is included in a Rust crate,
partial targets (like rlibs) will not link to the library, but when the rlib
is included in a final target (like a binary), the native library will be
linked in.</p>
</li>
</ul>
<p>On macOS, frameworks behave with the same semantics as a dynamic library.</p>
<h2 id="unsafe-blocks"><a class="header" href="#unsafe-blocks">Unsafe blocks</a></h2>
<p>Some operations, like dereferencing raw pointers or calling functions that have been marked
unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to
the compiler that the unsafety does not leak out of the block.</p>
<p>Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like
this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
<span class="boring">}</span></code></pre></pre>
<p>This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>
<h2 id="accessing-foreign-globals"><a class="header" href="#accessing-foreign-globals">Accessing foreign globals</a></h2>
<p>Foreign APIs often export a global variable which could do something like track
global state. In order to access these variables, you declare them in <code>extern</code>
blocks with the <code>static</code> keyword:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[link(name = "readline")]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!("You have readline version {} installed.",
             unsafe { rl_readline_version as i32 });
}</code></pre>
<p>Alternatively, you may need to alter global state provided by a foreign
interface. To do this, statics can be declared with <code>mut</code> so we can mutate
them.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use std::ffi::CString;
use std::ptr;

#[link(name = "readline")]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new("[my-awesome-shell] $").unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!("{:?}", rl_prompt);

        rl_prompt = ptr::null();
    }
}</code></pre>
<p>Note that all interaction with a <code>static mut</code> is unsafe, both reading and
writing. Dealing with global mutable state requires a great deal of care.</p>
<h2 id="foreign-calling-conventions"><a class="header" href="#foreign-calling-conventions">Foreign calling conventions</a></h2>
<p>Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when
calling foreign functions. Some foreign functions, most notably the Windows API, use other calling
conventions. Rust provides a way to tell the compiler which convention to use:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[cfg(all(target_os = "win32", target_arch = "x86"))]
#[link(name = "kernel32")]
#[allow(non_snake_case)]
extern "stdcall" {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
<span class="boring">fn main() { }</span></code></pre>
<p>This applies to the entire <code>extern</code> block. The list of supported ABI constraints
are:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>thiscall</code></li>
<li><code>vectorcall</code>
This is currently hidden behind the <code>abi_vectorcall</code> gate and is subject to change.</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p>Most of the abis in this list are self-explanatory, but the <code>system</code> abi may
seem a little odd. This constraint selects whatever the appropriate ABI is for
interoperating with the target's libraries. For example, on win32 with a x86
architecture, this means that the abi used would be <code>stdcall</code>. On x86_64,
however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This
means that in our previous example, we could have used <code>extern "system" { ... }</code>
to define a block for all windows systems, not only x86 ones.</p>
<h2 id="interoperability-with-foreign-code"><a class="header" href="#interoperability-with-foreign-code">Interoperability with foreign code</a></h2>
<p>Rust guarantees that the layout of a <code>struct</code> is compatible with the platform's
representation in C only if the <code>#[repr(C)]</code> attribute is applied to it.
<code>#[repr(C, packed)]</code> can be used to lay out struct members without padding.
<code>#[repr(C)]</code> can also be applied to an enum.</p>
<p>Rust's owned boxes (<code>Box&lt;T&gt;</code>) use non-nullable pointers as handles which point
to the contained object. However, they should not be manually created because
they are managed by internal allocators. References can safely be assumed to be
non-nullable pointers directly to the type.  However, breaking the borrow
checking or mutability rules is not guaranteed to be safe, so prefer using raw
pointers (<code>*</code>) if that's needed because the compiler can't make as many
assumptions about them.</p>
<p>Vectors and strings share the same basic memory layout, and utilities are
available in the <code>vec</code> and <code>str</code> modules for working with C APIs. However,
strings are not terminated with <code>\0</code>. If you need a NUL-terminated string for
interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code>
module.</p>
<p>The <a href="https://crates.io/crates/libc"><code>libc</code> crate on crates.io</a> includes type aliases and function
definitions for the C standard library in the <code>libc</code> module, and Rust links
against <code>libc</code> and <code>libm</code> by default.</p>
<h2 id="variadic-functions"><a class="header" href="#variadic-functions">Variadic functions</a></h2>
<p>In C, functions can be 'variadic', meaning they accept a variable number of arguments. This can
be achieved in Rust by specifying <code>...</code> within the argument list of a foreign function declaration:</p>
<pre><code class="language-no_run">extern {
    fn foo(x: i32, ...);
}

fn main() {
    unsafe {
        foo(10, 20, 30, 40, 50);
    }
}
</code></pre>
<p>Normal Rust functions can <em>not</em> be variadic:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This will not compile

fn foo(x: i32, ...) {}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-nullable-pointer-optimization"><a class="header" href="#the-nullable-pointer-optimization">The "nullable pointer optimization"</a></h2>
<p>Certain Rust types are defined to never be <code>null</code>. This includes references (<code>&amp;T</code>,
<code>&amp;mut T</code>), boxes (<code>Box&lt;T&gt;</code>), and function pointers (<code>extern "abi" fn()</code>). When
interfacing with C, pointers that might be <code>null</code> are often used, which would seem to
require some messy <code>transmute</code>s and/or unsafe code to handle conversions to/from Rust types.
However, trying to construct/work with these invalid values <strong>is undefined behavior</strong>,
so you should use the following workaround instead.</p>
<p>As a special case, an <code>enum</code> is eligible for the "nullable pointer optimization" if it contains
exactly two variants, one of which contains no data and the other contains a field of one of the
non-nullable types listed above.  This means no extra space is required for a discriminant; rather,
the empty variant is represented by putting a <code>null</code> value into the non-nullable field. This is
called an "optimization", but unlike other optimizations it is guaranteed to apply to eligible
types.</p>
<p>The most common type that takes advantage of the nullable pointer optimization is <code>Option&lt;T&gt;</code>,
where <code>None</code> corresponds to <code>null</code>. So <code>Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;</code> is a correct way
to represent a nullable function pointer using the C ABI (corresponding to the C type
<code>int (*)(int)</code>).</p>
<p>Here is a contrived example. Let's say some C library has a facility for registering a
callback, which gets called in certain situations. The callback is passed a function pointer
and an integer and it is supposed to run the function with the integer as a parameter. So
we have function pointers flying across the FFI boundary in both directions.</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::c_int;

<span class="boring">#[cfg(hidden)]
</span>extern "C" {
    /// Registers the callback.
    fn register(cb: Option&lt;extern "C" fn(Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}
<span class="boring">unsafe fn register(_: Option&lt;extern "C" fn(Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;,
</span><span class="boring">                                           c_int) -&gt; c_int&gt;)
</span><span class="boring">{}
</span>
/// This fairly useless function receives a function pointer and an integer
/// from C, and returns the result of calling the function with the integer.
/// In case no function is provided, it squares the integer by default.
extern "C" fn apply(process: Option&lt;extern "C" fn(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    match process {
        Some(f) =&gt; f(int),
        None    =&gt; int * int
    }
}

fn main() {
    unsafe {
        register(Some(apply));
    }
}</code></pre>
<p>And the code on the C side looks like this:</p>
<pre><code class="language-c">void register(int (*f)(int (*)(int), int)) {
    ...
}
</code></pre>
<p>No <code>transmute</code> required!</p>
<h2 id="ffi-and-unwinding"><a class="header" href="#ffi-and-unwinding">FFI and unwinding</a></h2>
<p>It’s important to be mindful of unwinding when working with FFI. Most
ABI strings come in two variants, one with an <code>-unwind</code> suffix and one without.
The <code>Rust</code> ABI always permits unwinding, so there is no <code>Rust-unwind</code> ABI.</p>
<p>If you expect Rust <code>panic</code>s or foreign (e.g. C++) exceptions to cross an FFI
boundary, that boundary must use the appropriate <code>-unwind</code> ABI string.
Conversely, if you do not expect unwinding to cross an ABI boundary, use one of
the non-<code>unwind</code> ABI strings.</p>
<blockquote>
<p>Note: Compiling with <code>panic=abort</code> will still cause <code>panic!</code> to immediately
abort the process, regardless of which ABI is specified by the function that
<code>panic</code>s.</p>
</blockquote>
<p>If an unwinding operation does encounter an ABI boundary that is
not permitted to unwind, the behavior depends on the source of the unwinding
(Rust <code>panic</code> or a foreign exception):</p>
<ul>
<li><code>panic</code> will cause the process to safely abort.</li>
<li>A foreign exception entering Rust will cause undefined behavior.</li>
</ul>
<p>Note that the interaction of <code>catch_unwind</code> with foreign exceptions <strong>is
undefined</strong>, as is the interaction of <code>panic</code> with foreign exception-catching
mechanisms (notably C++'s <code>try</code>/<code>catch</code>).</p>
<h3 id="rust-panic-with-c-unwind"><a class="header" href="#rust-panic-with-c-unwind">Rust <code>panic</code> with <code>"C-unwind"</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[no_mangle]
extern "C-unwind" fn example() {
    panic!("Uh oh");
}</code></pre>
<p>This function (when compiled with <code>panic=unwind</code>) is permitted to unwind C++
stack frames.</p>
<pre><code class="language-text">[Rust function with `catch_unwind`, which stops the unwinding]
      |
     ...
      |
[C++ frames]
      |                           ^
      | (calls)                   | (unwinding
      v                           |  goes this
[Rust function `example`]         |  way)
      |                           |
      +--- rust function panics --+
</code></pre>
<p>If the C++ frames have objects, their destructors will be called.</p>
<h3 id="c-throw-with-c-unwind"><a class="header" href="#c-throw-with-c-unwind">C++ <code>throw</code> with <code>"C-unwind"</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[link(...)]
extern "C-unwind" {
    // A C++ function that may throw an exception
    fn may_throw();
}

#[no_mangle]
extern "C-unwind" fn rust_passthrough() {
    let b = Box::new(5);
    unsafe { may_throw(); }
    println!("{:?}", &amp;b);
}</code></pre>
<p>A C++ function with a <code>try</code> block may invoke <code>rust_passthrough</code> and <code>catch</code> an
exception thrown by <code>may_throw</code>.</p>
<pre><code class="language-text">[C++ function with `try` block that invokes `rust_passthrough`]
      |
     ...
      |
[Rust function `rust_passthrough`]
      |                            ^
      | (calls)                    | (unwinding
      v                            |  goes this
[C++ function `may_throw`]         |  way)
      |                            |
      +--- C++ function throws ----+
</code></pre>
<p>If <code>may_throw</code> does throw an exception, <code>b</code> will be dropped. Otherwise, <code>5</code>
will be printed.</p>
<h3 id="panic-can-be-stopped-at-an-abi-boundary"><a class="header" href="#panic-can-be-stopped-at-an-abi-boundary"><code>panic</code> can be stopped at an ABI boundary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn assert_nonzero(input: u32) {
    assert!(input != 0)
}
<span class="boring">}</span></code></pre></pre>
<p>If <code>assert_nonzero</code> is called with the argument <code>0</code>, the runtime is guaranteed
to (safely) abort the process, whether or not compiled with <code>panic=abort</code>.</p>
<h3 id="catching-panic-preemptively"><a class="header" href="#catching-panic-preemptively">Catching <code>panic</code> preemptively</a></h3>
<p>If you are writing Rust code that may panic, and you don't wish to abort the
process if it panics, you must use <a href="rust/../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">use std::panic::catch_unwind;

#[no_mangle]
pub extern "C" fn oh_no() -&gt; i32 {
    let result = catch_unwind(|| {
        panic!("Oops!");
    });
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; 1,
    }
}

fn main() {}</code></pre></pre>
<p>Please note that <a href="rust/../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> will only catch unwinding panics, not
those that abort the process. See the documentation of <a href="rust/../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>
for more information.</p>
<h2 id="representing-opaque-structs"><a class="header" href="#representing-opaque-structs">Representing opaque structs</a></h2>
<p>Sometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants.
A stable and simple way is to use a <code>void *</code> argument:</p>
<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>
<p>We can represent this in Rust with the <code>c_void</code> type:</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">extern "C" {
    pub fn foo(arg: *mut libc::c_void);
    pub fn bar(arg: *mut libc::c_void);
}
<span class="boring">fn main() {}</span></code></pre>
<p>This is a perfectly valid way of handling the situation. However, we can do a bit
better. To solve this, some C libraries will instead create a <code>struct</code>, where
the details and memory layout of the struct are private. This gives some amount
of type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>
<pre><code class="language-c">struct Foo; /* Foo is a structure, but its contents are not part of the public interface */
struct Bar;
void foo(struct Foo *arg);
void bar(struct Bar *arg);
</code></pre>
<p>To do this in Rust, let’s create our own opaque types:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
pub struct Foo {
    _data: [u8; 0],
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}
#[repr(C)]
pub struct Bar {
    _data: [u8; 0],
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}

extern "C" {
    pub fn foo(arg: *mut Foo);
    pub fn bar(arg: *mut Bar);
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>By including at least one private field and no constructor,
we create an opaque type that we can't instantiate outside of this module.
(A struct with no field could be instantiated by anyone.)
We also want to use this type in FFI, so we have to add <code>#[repr(C)]</code>.
The marker ensures the compiler does not mark the struct as <code>Send</code>, <code>Sync</code> and <code>Unpin</code> are
not applied to the struct. (<code>*mut u8</code> is not <code>Send</code> or <code>Sync</code>, <code>PhantomPinned</code> is not <code>Unpin</code>)</p>
<p>But because our <code>Foo</code> and <code>Bar</code> types are
different, we’ll get type safety between the two of them, so we cannot
accidentally pass a pointer to <code>Foo</code> to <code>bar()</code>.</p>
<p>Notice that it is a really bad idea to use an empty enum as FFI type.
The compiler relies on empty enums being uninhabited, so handling values of type
<code>&amp;Empty</code> is a huge footgun and can lead to buggy program behavior (by triggering
undefined behavior).</p>
<blockquote>
<p><strong>NOTE:</strong> The simplest way would use "extern types".
But it's currently (as of June 2021) unstable and has some unresolved questions, see the <a href="https://rust-lang.github.io/rfcs/1861-extern-types.html">RFC page</a> and the <a href="https://github.com/rust-lang/rust/issues/43467">tracking issue</a> for more details.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>在Rust的内存分配中，程序的内存通常可以分为几个主要的区域：<strong>栈区</strong>、<strong>堆区</strong>、<strong>数据段</strong>（包括常量和静态变量的分配区域），以及<strong>代码段</strong>。不同的数据根据其生命周期、可变性和初始化状态，被分配到不同的区域。</p>
<h3 id="rust-内存分配的主要区域"><a class="header" href="#rust-内存分配的主要区域">Rust 内存分配的主要区域：</a></h3>
<ol>
<li>
<p><strong>栈区（Stack）</strong>：</p>
<ul>
<li>存储局部变量和临时数据，生命周期由作用域控制。</li>
<li>栈上的内存分配速度快，但大小有限。</li>
<li>通常，函数调用的参数和局部变量在栈上分配。</li>
</ul>
</li>
<li>
<p><strong>堆区（Heap）</strong>：</p>
<ul>
<li>动态分配的内存，如通过<code>Box</code>、<code>Rc</code>、<code>Vec</code>等智能指针进行的分配。</li>
<li>堆内存由程序员或Rust的所有权系统管理，生命周期灵活，但分配和释放的开销较大。</li>
<li>堆上的对象通过指针间接访问，因此访问速度较栈慢。</li>
</ul>
</li>
<li>
<p><strong>数据段（Data Segment）</strong>：</p>
<ul>
<li>包含全局变量、静态变量和常量。数据段又细分为以下几部分：</li>
</ul>
<ol>
<li>
<p><strong>已初始化数据段（.data segment）</strong>：</p>
<ul>
<li>存储已初始化的全局变量和静态变量。</li>
<li>例如，<code>static</code>关键字声明且显式初始化的变量会被存放在此处。它们在程序启动时被分配，并在程序结束时释放。</li>
<li>可读写。</li>
</ul>
</li>
<li>
<p><strong>未初始化数据段（.bss segment）</strong>：</p>
<ul>
<li>存储未初始化的全局变量和静态变量。</li>
<li>这些变量在程序启动时会被自动初始化为0，但在程序的可执行文件中不占用实际空间。Rust中的未初始化<code>static</code>变量会放在这里。</li>
<li>可读写。</li>
</ul>
</li>
<li>
<p><strong>只读数据段（.rodata segment，Read-Only Data Segment）</strong>：</p>
<ul>
<li>存储常量（<code>const</code>定义的值）和只读数据，如字符串字面量。</li>
<li>Rust中的常量不会像静态变量那样分配内存空间，而是嵌入到代码中；但字面量等不可变数据会存储在这个段。</li>
<li>只读，试图修改会导致运行时错误。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>代码段（Text Segment）</strong>：</p>
<ul>
<li>包含程序的可执行指令，是只读区域。</li>
<li>程序代码在编译时被放入此区域，执行时会从这里读取指令。</li>
</ul>
</li>
</ol>
<h3 id="常量和静态变量的分配"><a class="header" href="#常量和静态变量的分配">常量和静态变量的分配：</a></h3>
<ul>
<li>
<p><strong>常量（<code>const</code>）</strong>：</p>
<ul>
<li>常量在编译时确定，通常不会占用数据段中的内存空间。其值直接嵌入到程序的代码中。</li>
<li>如果常量是字符串字面量等，它们会存储在只读数据段（<code>.rodata</code>）。</li>
</ul>
</li>
<li>
<p><strong>静态变量（<code>static</code>）</strong>：</p>
<ul>
<li>静态变量在程序的整个生命周期内都存在。</li>
<li>已初始化的静态变量存放在<strong>已初始化数据段</strong>（<code>.data</code>）。</li>
<li>未初始化或默认初始化为0的静态变量存放在<strong>未初始化数据段</strong>（<code>.bss</code>）。</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a class="header" href="#总结-1">总结：</a></h3>
<ul>
<li><strong>栈区</strong>：局部变量、函数参数等。</li>
<li><strong>堆区</strong>：动态分配的对象，如<code>Box</code>、<code>Vec</code>等。</li>
<li><strong>数据段</strong>：
<ul>
<li><strong>已初始化数据段（.data）</strong>：已初始化的静态变量和全局变量。</li>
<li><strong>未初始化数据段（.bss）</strong>：未初始化的静态变量和全局变量，自动初始化为0。</li>
<li><strong>只读数据段（.rodata）</strong>：只读数据，如常量、字符串字面量。</li>
</ul>
</li>
<li><strong>代码段</strong>：程序的机器指令。</li>
</ul>
<p>常量和静态变量根据其初始化状态和可变性分配到不同的数据段，已初始化的数据进入<code>.data</code>，未初始化的数据进入<code>.bss</code>，而只读数据进入<code>.rodata</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust离线使用"><a class="header" href="#rust离线使用">Rust离线使用</a></h1>
<p>在没有网络连接的离线环境中，使用Rust进行工具链、组件和项目依赖的安装和管理是有些挑战的，但可以通过以下步骤解决：</p>
<h2 id="准备离线工具链和组件"><a class="header" href="#准备离线工具链和组件">准备离线工具链和组件</a></h2>
<p>Rust 的工具链和组件通过 Rustup 管理，你可以在有网络的机器上下载工具链和组件，并在离线机器上安装。</p>
<h3 id="步骤"><a class="header" href="#步骤">步骤：</a></h3>
<h4 id="在有网络的机器上"><a class="header" href="#在有网络的机器上">在有网络的机器上：</a></h4>
<ol>
<li>
<p>安装 Rustup：</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
</li>
<li>
<p>下载工具链和组件（例如稳定版工具链和 rust-src 组件）：</p>
<pre><code>rustup toolchain install stable
rustup component add rust-src --toolchain stable
</code></pre>
</li>
</ol>
<p>可以根据需要替换不同的版本或组件。</p>
<ol start="3">
<li>下载工具链和组件到本地缓存：
<pre><code>rustup update
</code></pre>
</li>
</ol>
<p>所有下载的工具链和组件会保存在本地 Rustup 的缓存目录下，通常位于 ~/.rustup。</p>
<h4 id="将缓存拷贝到离线环境"><a class="header" href="#将缓存拷贝到离线环境">将缓存拷贝到离线环境：</a></h4>
<ol>
<li>
<p>将 ~/.rustup 文件夹拷贝到离线的机器上相同路径下。</p>
</li>
<li>
<p>在离线机器上设置环境变量：</p>
<pre><code>export RUSTUP_HOME=~/.rustup
export CARGO_HOME=~/.cargo
</code></pre>
</li>
<li>
<p>验证 Rust 工具链是否可用：</p>
<pre><code>rustc --version
cargo --version
</code></pre>
</li>
</ol>
<h2 id="离线添加项目依赖"><a class="header" href="#离线添加项目依赖">离线添加项目依赖</a></h2>
<p>Rust 项目依赖通过 Cargo 管理，通常会从 crates.io 下载依赖。在离线环境下，可以提前下载依赖并手动管理。</p>
<h3 id="步骤-1"><a class="header" href="#步骤-1">步骤：</a></h3>
<h4 id="在有网络的机器上-1"><a class="header" href="#在有网络的机器上-1">在有网络的机器上：</a></h4>
<ol>
<li>进入项目目录，运行：
<pre><code>cargo fetch
</code></pre>
</li>
</ol>
<p>这会将项目的依赖下载到 ~/.cargo/registry 中。</p>
<ol start="2">
<li>
<p>如果想一次性下载多个项目的依赖，或者不同的版本，你可以提前配置好 Cargo.toml 文件并运行 cargo fetch。</p>
</li>
<li>
<p>将依赖缓存（~/.cargo/registry 和 ~/.cargo/git）拷贝到离线机器上。</p>
</li>
</ol>
<h4 id="在离线机器上"><a class="header" href="#在离线机器上">在离线机器上：</a></h4>
<ol>
<li>
<p>把从有网络的机器拷贝过来的 ~/.cargo/registry 和 ~/.cargo/git 放到离线机器上的相同目录下。</p>
</li>
<li>
<p>在项目目录中运行以下命令以确认依赖可用：</p>
<pre><code>cargo build
</code></pre>
</li>
</ol>
<p>通过上述步骤，你应该可以在离线环境中使用 Rust 工具链、组件以及管理项目依赖。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在Rust中，共享所有权和内部可变性是处理数据访问和修改的重要概念。这些概念通过特定的智能指针类型来实现，允许在多个所有者之间安全地共享数据，并在必要时允许内部修改。以下是关于这两种概念的详细解释和示例。</p>
<h3 id="共享所有权shared-ownership"><a class="header" href="#共享所有权shared-ownership">共享所有权（Shared Ownership）</a></h3>
<p>共享所有权是指多个变量可以拥有对同一块数据的所有权。在Rust中，使用 <code>Rc&lt;T&gt;</code>（引用计数智能指针）来实现共享所有权。<code>Rc&lt;T&gt;</code> 允许多个引用计数智能指针持有对同一数据的引用，而无需担心数据被提前释放。</p>
<h4 id="特点"><a class="header" href="#特点">特点：</a></h4>
<ol>
<li><strong>多重所有权</strong>：多个变量可以拥有对同一数据的所有权。</li>
<li><strong>引用计数</strong>：每个 <code>Rc&lt;T&gt;</code> 智能指针维护一个引用计数，当最后一个引用计数减少到零时，数据才会被释放。</li>
<li><strong>非线程安全</strong>：<code>Rc&lt;T&gt;</code> 不适用于多线程环境，因为它没有提供线程安全的引用计数机制。</li>
</ol>
<h4 id="示例使用-rct"><a class="header" href="#示例使用-rct">示例：使用 <code>Rc&lt;T&gt;</code></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let value = Rc::new(5); // 创建一个引用计数智能指针

    let a = Rc::clone(&amp;value); // 克隆一个新的引用计数智能指针
    let b = Rc::clone(&amp;value); // 再次克隆

    println!("Count after cloning: {}", Rc::strong_count(&amp;value)); // 输出引用计数

    // 输出原始值
    println!("a contains {}", a);
    println!("b contains {}", b);

    // 修改 `a` 的值是不可能的，因为 `a` 和 `b` 都是不可变的引用
    // *a = 10; // 这里会编译失败
}</code></pre></pre>
<h3 id="内部可变性interior-mutability"><a class="header" href="#内部可变性interior-mutability">内部可变性（Interior Mutability）</a></h3>
<p>内部可变性是指在一个共享引用存在的情况下，仍然能够修改数据的能力。这通常是通过使用 <code>RefCell&lt;T&gt;</code> 来实现的。<code>RefCell&lt;T&gt;</code> 允许在运行时检查借用规则，而不是在编译时检查。</p>
<h4 id="特点-1"><a class="header" href="#特点-1">特点：</a></h4>
<ol>
<li><strong>运行时检查</strong>：<code>RefCell&lt;T&gt;</code> 在运行时而不是编译时检查借用规则。</li>
<li><strong>可变借用</strong>：即使存在不可变引用，也可以通过 <code>RefCell&lt;T&gt;</code> 获得可变借用。</li>
<li><strong>互斥锁</strong>：<code>RefCell&lt;T&gt;</code> 内部使用互斥锁来确保在任何时刻只有一个借用（可变或不可变）。</li>
</ol>
<h4 id="示例使用-refcellt"><a class="header" href="#示例使用-refcellt">示例：使用 <code>RefCell&lt;T&gt;</code></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

fn main() {
    let r = RefCell::new(5); // 创建一个 `RefCell&lt;T&gt;`

    // 获取不可变借用
    {
        let borrowed = r.borrow(); // 不可变借用
        println!("Borrowed value: {}", *borrowed);
    }

    // 获取可变借用并修改值
    {
        let mut borrowed = r.borrow_mut(); // 可变借用
        *borrowed = 10;
        println!("Mutably borrowed value: {}", *borrowed);
    }

    // 再次获取不可变借用，此时值已被修改
    {
        let borrowed = r.borrow();
        println!("Final borrowed value: {}", *borrowed);
    }
}</code></pre></pre>
<h3 id="结合使用-rcrefcellt"><a class="header" href="#结合使用-rcrefcellt">结合使用 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code></a></h3>
<p>在一些情况下，你可能需要同时实现共享所有权和内部可变性。这时候可以使用 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 来组合这两种特性。这允许你在多个所有者之间共享数据，并且能够在运行时安全地修改数据。</p>
<h4 id="示例使用-rcrefcellt"><a class="header" href="#示例使用-rcrefcellt">示例：使用 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code></a></h4>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5)); // 创建一个 `Rc&lt;RefCell&lt;T&gt;&gt;`

    let a = Rc::clone(&amp;value); // 克隆 `Rc&lt;RefCell&lt;T&gt;&gt;`
    let b = Rc::clone(&amp;value); // 再次克隆

    // 修改 `a` 中的值
    {
        let mut v = a.borrow_mut();
        *v = 10;
    }

    // 打印 `b` 中的值，此时值已被修改
    println!("Value in `b`: {}", *b.borrow());
}</code></pre></pre>
<p>在这个例子中，<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 允许我们创建多个所有者，并且每个所有者都可以通过 <code>RefCell&lt;T&gt;</code> 来获得可变借用，从而修改数据。</p>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<ul>
<li><strong>共享所有权</strong>：通过 <code>Rc&lt;T&gt;</code> 实现，允许多个所有者共享数据。</li>
<li><strong>内部可变性</strong>：通过 <code>RefCell&lt;T&gt;</code> 实现，在有共享引用的情况下安全地修改数据。</li>
<li><strong>结合使用</strong>：通过 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 实现共享所有权和内部可变性的组合。</li>
</ul>
<p>这些特性使得Rust在保持类型安全的同时，能够灵活地处理数据的共享和修改，尤其是在复杂的数据结构和并发编程场景中。</p>
<div style="break-before: page; page-break-before: always;"></div><p>Windows系统服务是一类特殊的程序，它们可以在系统启动时自动运行，并在后台持续运行而无需用户交互。服务可以执行多种任务，例如管理硬件设备、监听网络请求、维护系统日志等。下面我将详细介绍如何管理和操作Windows系统服务。</p>
<h3 id="1-查看服务"><a class="header" href="#1-查看服务">1. 查看服务</a></h3>
<ul>
<li><strong>服务管理器</strong>：打开“服务”管理器，可以通过在开始菜单搜索框中输入 <code>services.msc</code> 并回车来快速访问。</li>
<li><strong>命令行</strong>：使用 <code>sc query</code> 命令列出所有服务，例如：
<pre><code class="language-cmd">sc query
</code></pre>
</li>
</ul>
<h3 id="2-启动停止重启服务"><a class="header" href="#2-启动停止重启服务">2. 启动、停止、重启服务</a></h3>
<ul>
<li><strong>服务管理器</strong>：
<ul>
<li>右键点击服务，选择“启动”、“停止”或“重启”。</li>
<li>或者，在服务列表中双击服务名称打开服务属性对话框，然后点击“服务状态”标签页，使用相应的按钮。</li>
</ul>
</li>
<li><strong>命令行</strong>：
<ul>
<li>启动服务：<code>net start servicename</code></li>
<li>停止服务：<code>net stop servicename</code></li>
<li>重启服务：先停止再启动，或者使用 PowerShell 的 <code>Restart-Service</code> 命令。</li>
</ul>
</li>
</ul>
<h3 id="3-配置服务属性"><a class="header" href="#3-配置服务属性">3. 配置服务属性</a></h3>
<ul>
<li><strong>服务管理器</strong>：
<ul>
<li>双击服务或右键点击服务并选择“属性”。</li>
<li>在服务属性对话框中，可以修改启动类型（自动、手动、禁用）、服务描述、登录身份等。</li>
</ul>
</li>
<li><strong>命令行</strong>：
<ul>
<li>修改启动类型：<code>sc config servicename start= auto|manual|disabled</code></li>
<li>修改服务描述：<code>sc description servicename "new description"</code></li>
<li>更改服务账户：<code>sc config servicename obj= "domain\username" password= "password"</code></li>
</ul>
</li>
</ul>
<h3 id="4-创建新的服务"><a class="header" href="#4-创建新的服务">4. 创建新的服务</a></h3>
<ul>
<li><strong>命令行</strong>：
<ul>
<li>使用 <code>sc create</code> 命令创建服务：
<pre><code class="language-cmd">sc create servicename binPath= "path\to\service.exe" DisplayName= "Service Display Name"
</code></pre>
</li>
<li>配置服务启动类型和其他选项：
<pre><code class="language-cmd">sc config servicename start= auto
</code></pre>
</li>
</ul>
</li>
<li><strong>图形界面</strong>：
<ul>
<li>使用“创建基本服务”向导（通常需要第三方工具或脚本辅助，因为Windows本身没有内置的图形界面创建服务的向导）。</li>
</ul>
</li>
</ul>
<h3 id="5-删除服务"><a class="header" href="#5-删除服务">5. 删除服务</a></h3>
<ul>
<li><strong>服务管理器</strong>：
<ul>
<li>找到服务，右键点击并选择“删除”。</li>
</ul>
</li>
<li><strong>命令行</strong>：
<ul>
<li>使用 <code>sc delete</code> 命令删除服务：
<pre><code class="language-cmd">sc delete servicename
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6-其他操作"><a class="header" href="#6-其他操作">6. 其他操作</a></h3>
<ul>
<li><strong>查询服务状态</strong>：
<ul>
<li>使用 <code>sc query servicename</code> 命令查询服务的状态。</li>
</ul>
</li>
<li><strong>查看服务日志</strong>：
<ul>
<li>使用事件查看器（Event Viewer）查看与服务相关的事件日志。</li>
</ul>
</li>
<li><strong>PowerShell</strong>：
<ul>
<li>使用 PowerShell 的 <code>Get-Service</code>、<code>Start-Service</code>、<code>Stop-Service</code> 和 <code>Set-Service</code> 命令进行更高级的服务管理。</li>
</ul>
</li>
</ul>
<h3 id="示例创建并启动一个简单的服务"><a class="header" href="#示例创建并启动一个简单的服务">示例：创建并启动一个简单的服务</a></h3>
<p>假设你需要创建一个名为 <code>MyService</code> 的服务，它的可执行文件位于 <code>C:\Path\To\MyService.exe</code>，并且希望它在系统启动时自动运行。</p>
<h4 id="创建服务"><a class="header" href="#创建服务">创建服务</a></h4>
<ul>
<li>使用命令行：
<pre><code class="language-cmd">sc create MyService binPath= "C:\Path\To\MyService.exe" DisplayName= "My Service"
</code></pre>
</li>
</ul>
<h4 id="设置启动类型为自动"><a class="header" href="#设置启动类型为自动">设置启动类型为自动</a></h4>
<ul>
<li>使用命令行：
<pre><code class="language-cmd">sc config MyService start= auto
</code></pre>
</li>
</ul>
<h4 id="启动服务"><a class="header" href="#启动服务">启动服务</a></h4>
<ul>
<li>使用命令行：
<pre><code class="language-cmd">net start MyService
</code></pre>
</li>
</ul>
<p>以上就是关于Windows系统服务的一些基本操作和管理方式。根据实际需求，你可以选择最适合自己的方法来管理服务。如果你有任何具体的问题或需要进一步的帮助，请随时告诉我。</p>
<div style="break-before: page; page-break-before: always;"></div><p>Windows系统服务是一类特殊的程序，它们可以在系统启动时自动运行，并在后台持续运行而无需用户交互。服务可以执行多种任务，例如管理硬件设备、监听网络请求、维护系统日志等。下面我将详细介绍如何管理和操作Windows系统服务。</p>
<h3 id="1-查看服务-1"><a class="header" href="#1-查看服务-1">1. 查看服务</a></h3>
<ul>
<li><strong>服务管理器</strong>：打开“服务”管理器，可以通过在开始菜单搜索框中输入 <code>services.msc</code> 并回车来快速访问。</li>
<li><strong>命令行</strong>：使用 <code>sc query</code> 命令列出所有服务，例如：
<pre><code class="language-cmd">sc query
</code></pre>
</li>
</ul>
<h3 id="2-启动停止重启服务-1"><a class="header" href="#2-启动停止重启服务-1">2. 启动、停止、重启服务</a></h3>
<ul>
<li><strong>服务管理器</strong>：
<ul>
<li>右键点击服务，选择“启动”、“停止”或“重启”。</li>
<li>或者，在服务列表中双击服务名称打开服务属性对话框，然后点击“服务状态”标签页，使用相应的按钮。</li>
</ul>
</li>
<li><strong>命令行</strong>：
<ul>
<li>启动服务：<code>net start servicename</code></li>
<li>停止服务：<code>net stop servicename</code></li>
<li>重启服务：先停止再启动，或者使用 PowerShell 的 <code>Restart-Service</code> 命令。</li>
</ul>
</li>
</ul>
<h3 id="3-配置服务属性-1"><a class="header" href="#3-配置服务属性-1">3. 配置服务属性</a></h3>
<ul>
<li><strong>服务管理器</strong>：
<ul>
<li>双击服务或右键点击服务并选择“属性”。</li>
<li>在服务属性对话框中，可以修改启动类型（自动、手动、禁用）、服务描述、登录身份等。</li>
</ul>
</li>
<li><strong>命令行</strong>：
<ul>
<li>修改启动类型：<code>sc config servicename start= auto|manual|disabled</code></li>
<li>修改服务描述：<code>sc description servicename "new description"</code></li>
<li>更改服务账户：<code>sc config servicename obj= "domain\username" password= "password"</code></li>
</ul>
</li>
</ul>
<h3 id="4-创建新的服务-1"><a class="header" href="#4-创建新的服务-1">4. 创建新的服务</a></h3>
<ul>
<li><strong>命令行</strong>：
<ul>
<li>使用 <code>sc create</code> 命令创建服务：
<pre><code class="language-cmd">sc create servicename binPath= "path\to\service.exe" DisplayName= "Service Display Name"
</code></pre>
</li>
<li>配置服务启动类型和其他选项：
<pre><code class="language-cmd">sc config servicename start= auto
</code></pre>
</li>
</ul>
</li>
<li><strong>图形界面</strong>：
<ul>
<li>使用“创建基本服务”向导（通常需要第三方工具或脚本辅助，因为Windows本身没有内置的图形界面创建服务的向导）。</li>
</ul>
</li>
</ul>
<h3 id="5-删除服务-1"><a class="header" href="#5-删除服务-1">5. 删除服务</a></h3>
<ul>
<li><strong>服务管理器</strong>：
<ul>
<li>找到服务，右键点击并选择“删除”。</li>
</ul>
</li>
<li><strong>命令行</strong>：
<ul>
<li>使用 <code>sc delete</code> 命令删除服务：
<pre><code class="language-cmd">sc delete servicename
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="6-其他操作-1"><a class="header" href="#6-其他操作-1">6. 其他操作</a></h3>
<ul>
<li><strong>查询服务状态</strong>：
<ul>
<li>使用 <code>sc query servicename</code> 命令查询服务的状态。</li>
</ul>
</li>
<li><strong>查看服务日志</strong>：
<ul>
<li>使用事件查看器（Event Viewer）查看与服务相关的事件日志。</li>
</ul>
</li>
<li><strong>PowerShell</strong>：
<ul>
<li>使用 PowerShell 的 <code>Get-Service</code>、<code>Start-Service</code>、<code>Stop-Service</code> 和 <code>Set-Service</code> 命令进行更高级的服务管理。</li>
</ul>
</li>
</ul>
<h3 id="示例创建并启动一个简单的服务-1"><a class="header" href="#示例创建并启动一个简单的服务-1">示例：创建并启动一个简单的服务</a></h3>
<p>假设你需要创建一个名为 <code>MyService</code> 的服务，它的可执行文件位于 <code>C:\Path\To\MyService.exe</code>，并且希望它在系统启动时自动运行。</p>
<h4 id="创建服务-1"><a class="header" href="#创建服务-1">创建服务</a></h4>
<ul>
<li>使用命令行：
<pre><code class="language-cmd">sc create MyService binPath= "C:\Path\To\MyService.exe" DisplayName= "My Service"
</code></pre>
</li>
</ul>
<h4 id="设置启动类型为自动-1"><a class="header" href="#设置启动类型为自动-1">设置启动类型为自动</a></h4>
<ul>
<li>使用命令行：
<pre><code class="language-cmd">sc config MyService start= auto
</code></pre>
</li>
</ul>
<h4 id="启动服务-1"><a class="header" href="#启动服务-1">启动服务</a></h4>
<ul>
<li>使用命令行：
<pre><code class="language-cmd">net start MyService
</code></pre>
</li>
</ul>
<p>以上就是关于Windows系统服务的一些基本操作和管理方式。根据实际需求，你可以选择最适合自己的方法来管理服务。如果你有任何具体的问题或需要进一步的帮助，请随时告诉我。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pg"><a class="header" href="#pg">pg</a></h1>
<h2 id="function"><a class="header" href="#function">function</a></h2>
<h3 id="coalesce"><a class="header" href="#coalesce">coalesce</a></h3>
<pre><code>coalesce(a, b, c)
</code></pre>
<blockquote>
<p>Return the first non null value. If all values are null, return null.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pg-1"><a class="header" href="#pg-1">pg</a></h1>
<h2 id="function-1"><a class="header" href="#function-1">function</a></h2>
<h3 id="coalesce-1"><a class="header" href="#coalesce-1">coalesce</a></h3>
<pre><code>coalesce(a, b, c)
</code></pre>
<blockquote>
<p>Return the first non null value. If all values are null, return null.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
