Rust 的数据类型核心分为值类型（Value Types） 和引用类型（Reference Types） 两大类，各类别下包含具体子类型，整体结构如下：

一、值类型（Value Types）

值类型在赋值或传递时会发生深拷贝（Copy 特质）或移动（Move 语义），数据存储在栈上（部分复合类型如智能指针会在堆上存储数据，但自身仍在栈上）。

•	基本值类型：存储简单数据，默认实现 Copy 特质。

	◦	整数类型：i8/i16/i32/i64/i128（有符号）、u8/u16/u32/u64/u128（无符号）、isize（与平台位数一致的有符号）、usize（与平台位数一致的无符号）。
	
	◦	浮点数类型：f32（单精度）、f64（双精度）。
	
	◦	布尔类型：bool（值为 true 或 false）。
	
	◦	字符类型：char（存储 Unicode 字符，占 4 字节，如 'a'、'中'）。

•	复合值类型：组合多个值，按存储方式和语义分为以下几种。

	◦	元组（Tuple）：固定长度、不同类型值的组合，如 (i32, &str, bool)。

	◦	数组（Array）：固定长度、相同类型值的组合，如 [i32; 5]（5 个 i32 的数组）。

	◦	结构体（Struct）：自定义的复合类型，可包含不同类型字段，如 struct Person { name: &str, age: i32 }。

	◦	枚举（Enum）：自定义的枚举类型，代表多个可能的取值，如 enum Option<T> { Some(T), None }。

•	智能指针：本质是封装了指针的结构体（值类型），用于管理堆内存，实现复杂内存语义。

	◦	Box<T>：最简单的智能指针，将数据存储在堆上，栈上仅存指向堆数据的指针。

	◦	Rc<T>/Arc<T>：分别实现单线程、多线程下的引用计数，允许数据被多个所有者共享。

	◦	Ref<T>/RefMut<T>：通过 RefCell<T> 借用的智能指针，实现运行时可变借用检查。

二、引用类型（Reference Types）

引用类型仅持有数据的“引用”（内存地址），不拥有数据，赋值或传递时不会拷贝数据本身，默认遵循“借用规则”（避免悬垂引用、数据竞争）。

•	裸指针（Raw Pointers）：无安全检查的指针，需手动管理生命周期和内存安全，仅用于unsafe场景。

	◦	不可变裸指针：*const T（只能读取指向的数据，不能修改）。

	◦	可变裸指针：*mut T（可读取和修改指向的数据）。

•	胖指针（Fat Pointers）：除内存地址外，还携带额外元数据的引用，常见两种形式。

	◦	切片（Slice）：如 &[T]（字节切片 &[u8]）、&str（字符串切片），携带“数据地址 + 长度”。

	◦	特征对象（Trait Object）：如 &dyn Trait、Box<dyn Trait>，携带“数据地址 + 虚表指针（vtable）”，用于实现动态多态。
