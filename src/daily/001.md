数据库事务隔离级别（Transaction Isolation Levels）是数据库管理系统（DBMS）为解决并发事务可能引发的问题（如脏读、不可重复读、幻读等）而定义的规则集合。不同隔离级别在一致性和并发性能之间权衡，开发者需根据业务需求选择合适的级别。以下是四种标准隔离级别的详细介绍：


------

1. 读未提交（Read Uncommitted）

• 核心规则：事务可以读取其他事务未提交的修改（“脏数据”）。

• 可能的问题：

  ◦ 脏读（Dirty Read）：事务A读取了事务B未提交的数据，若事务B后续回滚，事务A读到的数据即为无效。

• 适用场景：几乎不使用，仅用于对数据一致性要求极低且追求极致性能的场景（如实时监控非关键数据）。


------

2. 读已提交（Read Committed）

• 核心规则：事务只能读取其他事务已提交的修改。

• 解决脏读：避免了脏读问题，但可能引发以下问题：

  ◦ 不可重复读（Non-repeatable Read）：事务A多次读取同一数据时，若其他事务B在此期间提交了修改，事务A两次读取的结果可能不同。

• 实现方式：多数数据库（如Oracle、PostgreSQL默认级别）通过“快照读”或“行级锁”实现。例如，PostgreSQL在每次查询时生成数据的快照（基于事务ID），确保读取的是已提交的数据版本。


------

3. 可重复读（Repeatable Read）

• 核心规则：事务内多次读取同一数据时，结果必须一致（即使其他事务提交了修改）。

• 解决不可重复读：通过锁定读取的数据范围（如行锁或版本控制）避免其他事务修改已读取的数据。

• 可能的问题：

  ◦ 幻读（Phantom Read）：事务A查询某条件下的数据时，若其他事务B插入了符合该条件的新数据并提交，事务A再次查询可能看到“幻影行”。

• 实现方式：

  ◦ MySQL InnoDB：通过多版本并发控制（MVCC）+ 间隙锁（Gap Lock）解决幻读。例如，在可重复读级别下，InnoDB会对查询范围内的“间隙”加锁，阻止其他事务插入新数据。

  ◦ 其他数据库：部分数据库（如SQL Server默认级别）可能仅通过快照读避免不可重复读，但无法完全避免幻读（需显式加锁或升级到串行化）。


------

4. 串行化（Serializable）

• 核心规则：事务完全串行执行，如同一个事务接一个事务执行，彻底避免并发冲突。

• 解决所有问题：脏读、不可重复读、幻读均被避免。

• 实现方式：

  ◦ 悲观锁：对事务涉及的数据加排他锁，其他事务必须等待当前事务提交或回滚后才能访问。

  ◦ 乐观锁：通过版本号或时间戳检测冲突，若发现冲突则回滚事务（性能较低，适用于冲突较少的场景）。

• 代价：并发性能最低，仅用于对数据一致性要求极高的场景（如金融交易）。


------

隔离级别与并发问题的关系总结

隔离级别	脏读	不可重复读	幻读
读未提交	✅	✅	✅
读已提交	❌	✅	✅
可重复读	❌	❌	⚠️（可能）
串行化	❌	❌	❌

⚠️ 注：可重复读在部分数据库（如MySQL InnoDB）中可通过MVCC+间隙锁避免幻读，但并非所有数据库都支持。


------

不同数据库的默认隔离级别

• MySQL InnoDB：可重复读（通过MVCC和间隙锁优化幻读）。

• Oracle/PostgreSQL：读已提交（PostgreSQL通过快照隔离进一步减少不可重复读问题）。

• SQL Server：读已提交（默认），但支持快照隔离（Snapshot Isolation）作为可选级别。


------

如何选择隔离级别？

• 高并发、低一致性要求：读已提交或可重复读（如电商商品列表查询）。

• 强一致性、低并发：串行化（如银行转账）。

• 平衡场景：可重复读（如订单状态更新，需避免重复扣款）。

实际应用中，需结合业务需求、数据库特性及性能测试综合选择。例如，MySQL的InnoDB在可重复读级别下通过MVCC和间隙锁实现了接近串行化的隔离效果，同时保持了较高的并发性能。